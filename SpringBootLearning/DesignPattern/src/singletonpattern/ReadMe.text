单例模式：确保一个类在任何情况下都绝对只有一个实例
该包文件阅读路径：
HungrySingleton：饿汉式单例模式，在类加载时就立即初始化，并创建实例对象，有时候会用不到，造成内存浪费，线程安全
LazySingleton：懒汉式单例模式，在外部类调用时，内部类才会加载实例对象，但是线程不安全
ExecutorThread：创建懒汉式单例模式线程，测试线程不安全
LazySingletonTest：线程不安全测试类
LazySingletonThreadSafe：使用synchronized关键字检测锁，解决了线程安全的问题，但线程过多又会导致程序性能下降
LazyDoubleCheckSingleton: 使用关键字 volatile 和 synchronized 保证性能，
                          但是在getInstance()方法内还是会有阻塞，逻辑不太复杂的情况下，调用者感知不到，总归还是有问题
                          解决办法：采用静态内部类的方式
LazyInnerStaticClassSingleton： 兼顾了饿汉式的内存浪费问题和 synchronized 的性能问题，
                                完美屏避这两个问题。内部类在调用之前就会初始化，避免了线程不安全的问题

------------------------------------------------------------------------------------------
LazyInnerStaticClassSingletonTest：测试Java反射破坏单例模式的创建问题，这里出现了两个不同的对象
LazyInnerStaticClassSingletonPlus：对构造方法进行限制，出现多次重复创建，抛出异常。
这个方法基本上算是单例模式的完美创建
------------------------------------------------------------------------------------------
反序列化破坏单例模式：
序列化就是把内存中的状态通过转换成字节码的形式，从而转换成I/O流，写入到其他地方，可以是磁盘，也可以是网络I/O，内存的状态就会永久保存下来
反序列化就是把保存的序列化字节码，转换成I/O流，再把I/O流转换成Java对象，在转换的过程中会重新创建对象 new
因为序列化保存的内存状态是单例模式的，那么反序列化的对象也应该是单例的，在这个过程创建了两个不同的对象，就是反序列化破坏了单例模式

SerializeSingletonTest：对饿汉式单例模式进行测试反序列化破坏单例模式
SerializeSingletonTestPlus：添加readResolve()方法解决反序列化问题，但仍然是创建了两次对象，新创建的对象不反回，内存仍会损耗，
------------------------------------------------------------------------------------------
解决办法：注册式单例模式。注册式单例模式有两种：枚举式单例模式和容器式单例模式
EnumSingleton: 枚举式单例模式创建
EnumSingletonTest: 枚举式单例模式测试，关键要理解枚举的实现，INSTANCE指代了data对象
ContainerSingleton： 容器式单例模式，里面可以看出Spring IOC的设计思路



平时使用饿汉式单例模式就可以了，如果需要懒加载，建议使用内部静态类方法创建，如果遇到反序列化的问题，就使用枚举式单例模式












